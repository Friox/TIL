# 2025. 05. 27.

## 🍀 IT 직군 채용 시장 동향 및 지원 전략
- 최근 기업들은 TO를 줄이고 AI 활용을 강화하면서 지원 대비 경쟁률이 높아지고 있다.
- 따라서 이력서에서 인상적인 내용이 없으면 포트폴리오를 열어보지도 않고 탈락시키는 경우가 많다.
- 포트폴리오가 보기힘들게 난잡하다면 검토하지 않고 이력서만 보고 판단하기도 한다.
- 애매한 포트폴리오보다는 이력서에 집중하는 것이 더 나은 전략일수도 있다.
- 포트폴리오를 준비한다면 차별화된 구성과 명확한 전달력이 필요할것이다.

## 🍀 포트폴리오와 이력서 작성 방법
- 포트폴리오는 이력서에 담기 어려운 구체적 프로젝트 경험을 보여주고, 직무 역량과 신뢰도를 높인다.
- 일반적으로 2~3개의 주요 프로젝트를 소개하는 것이 적당하다. 특별한 프로젝트라면 더 소개해도 무방하다.
- 포트폴리오 양식은 PPT를 PDF로 변환하여 사용하거나, Notion, Google Docs 등 문서 형태도 가능하다.  
강사님은 PPT를 추천하고, Google Docs를 사용중이라고 한다.
- 각 프로젝트는 목차와 타이틀 슬라이드로 구분해 가독성을 높이자.

## 🍀 자기소개 작성 방법
- 다른거 다 필요없고 자신이 누군지 밝히는것에 집중하자.
- 자신이 선호하는 업무 환경, 협업 방식, 기술 분야, 가치관 등을 소개한다.  
(예: 아키텍처를 설계하는 것을 좋아한다, QA 하는것을 싫어하지 않는다. 등)
- 블로그, 발표 경험, 직무 전환 등 자신을 드러낼 수 있는 요소를 포함한다.
- 기술적인 내용(예: 사용 기술, 인프라 경험 등)은 이력서나 프로젝트 소개에서 다루는 것이 더 설득력 있다.

## 🍀 프로젝트 소개 작성 방법
- 이력서에는 간단한 프로젝트 소개, 포트폴리오에는 상세한 역할, 기여, 기술 스택, 아키텍처, 이미지, 다이어그램 등을 포함한다.
- 코드 자체 보다는 프로젝트 이해를 돕는 시각 자료가 중요하다.
- 프로젝트에 대한 깊은 이해와 애정을 보여줄 수 있어야 한다.
- 백엔드 직무라면 DB Explain, 모니터링 대시보드, 성능 비교 등 추가 자료를 넣으면 좋다.
- 프로젝트는 단순 나열이 아니라 문제 정의, 해결 과정, 결과 등 스토리텔링 방식이 효과적이다.
- 결과가 명확히 드러나는 프로젝트(MAU 등 다양한 데이터 존재, 복잡한 아키텍처 등)가 좋다.
- 지원하는 회사의 도메인, 기술 스택, 개발 문화에 맞춰 프로젝트를 선택하고 구성한다.  
(일종의 마스터 포트폴리오를 두고, 회사에 맞게 Branch 하는 전략 추천)
- 여러 프로젝트에서 동일한 기능 반복은 과감히 제거하고, 깊이 고민하고 기술적으로 고도화한 프로젝트 강조.
- 기술 선택의 이유와 결과를 명확히 설명할 수 있어야 한다. (예: 왜 Redis를 이용한 캐시를 도입했는지)
- 배운점 보다는 실제로 한 내용을 넣자, 소프트 스킬이나 갈등 해소는 크게 도움이 되지는 않는다. (예: ~경험을 얻었습니다, ~를 배웠습니다.)
- 면접관 입장에서는 이 사람이 뭘 할 수 있는지가 더 중요하다.

## 🍀 학력, 경력
- 포트폴리오 학력 기재는 불필요하다. 필요하다면 소개 페이지에 간단히 명시하자.
- 이력서에는 졸업 여부, 전공 등 확인을 위해 기재하는 것이 좋다.
- 경력이 쌓이면 이력서만 사용하기도 한다.

## 🍀 면접 및 후속 준비
- 포트폴리오 작성 후, 면접 대비는 필수다. 포트폴리오의 모든 내용에 대해 깊이 이해하고 있어야 한다.
- 왜 이 기술 스택을 선택했는지, 어떻게 구현했는지, 수치의 근거, 다른 방법은 왜 사용하지 않았는지 등 꼬리질문에 대비하자.
- 이력서와 포트폴리오의 내용이 자연스럽게 이어지도록 구성하자. 연관없는 내용이면 알아보기 힘들다.
- 주변 개발자, 선배, 멘토 등에게 피드백을 꼭 받자.
(LinkedIn DM, 인프런 멘토링 등)

## 🍀 결론
- 애매한 포트폴리오보다는 이력서에 집중.
- 포트폴리오와 이력서 모두 양보다 질이 중요.
- 프로젝트 경험은 깊이 있고 구체적으로, ‘문제 정의 → 해결 → 결과’의 스토리텔링 방식으로 작성.
- 작성 후 면접 대비와 피드백은 필수.

## 🍀 클라우드 기본 개념
### 온프레미스(On-Premise)
- IT 자원을 조직 내부에 직접 설치하고 운영, 관리하는 방식
- 물리적 접근이 제한되므로 보안성이 뛰어남.
- 원하는대로 서버 스펙에 대한 구성이 가능하다.

### 클라우드
- IT 자원을 인터넷을 통해 필요할 때마다 제공받아 사용하는 온디맨드(On-Demand) 서비스 모델
- 서버 랙과 같은 초기 설치 비용이 없다, 서버 랙이 필요 없으니 확장성이 뛰어나다.
- 자동 백업과 복구 옵션 등을 제공받을 수 있음.
- 인트라넷과 인터넷을 분리하지 않아도 분리된 네트워크를 보장받을 수 있다.
- 인터넷 연결이 되지 않으면 조작이 불가능하다.
- 확장성에 너무 치중하면 당월에 청구되는 요금 예측이 어렵다.

### CSP(Cloud Service Provider)
- 클라우드 기반 인프라와 플랫폼, 소프트웨어를 인터넷을 통해 제공하는 기업  
(해외 CSP는 주로 AWS, Azure, GCP가 있고, 국내 기업으로는 NCP, KiC가 있다.)
- IaaS, PaaS, SaaS를 제공한다. 실질적으로 제일 많이 사용하는 건 VM 등을 사용하기 위한 IaaS임.  
(IaaS: Infrastructure as a Service, PaaS: Platform as a Service, SaaS: Software as a Service)

### Cloud-Native
- 클라우드 환경에 최적화된 설계, 운영방식으로 컨테이너, 마이크로서비스, DevOps등을 결합해 유연성과 확장성을 확보한다.
- 클라우드 네이티브의 4대 원칙(CNCF 기준)
    - 컨테이너화 : 앱을 컨테이너로 격리하고 이식가능하게 패키징
    - 동적 오케스트레이션 : 컨테이너를 자동으로 배포, 관리, 스케일링
    - 마이크로서비스 : 앱을 작은 독립적인 서비스 단위로 분리
    - 불변 인프라 : 배포 단위는 수정 없이 교체(CI/CD 자동화)
- 주요 기술 스택
    - 컨테이너 : Docker, containerd
    - 오케스트레이션 : Kubernetes, OpenShift
    - 서비스 메시 : Istio, Linkerd
    - CI : GitHub Action, Jenkins
    - CD : ArgoCD, FluxCD
    - 모니터링, 로깅 : Prometheus, Grafana, ELK Stack 등등

## 🍀 CI(Continous Integration)
- 개발자가 작성한 코드를 공동 저장소에 자주 통합하고, 자동으로 빌드 및 테스트를 수행하는 일련과정의 총칭
- ‘코드 푸시 → 트리거 → 빌드 → 테스트 → 결과’가 일반적인 흐름이다. 테스트를 하지 않는 경우도 있다.
- 대표적인 CI 도구로 ‘Jenkins’, ‘GitHub Actions’, ‘GitLab CI’ 등이 있다.
- 빌드 시 진행되는 테스트로 오류 선검증이 가능하고, 잦은 빌드로 오류사항을 최소화 할 수 있다. 또한 협업의 효율이 향상된다.

## 🍀 CD(Continous Delivery/Deployment)
- CI 이후의 단계를 자동화하여 코드를 안정적으로 운영 환경까지 전달(배포)하는 프로세스.
- Continous Delivery와 Deployment의 가장 큰 차이점은
    - Delivery는 테스트 후 승인이 필요하고, Deployment는 승인이 필요하지 않다.
    - Delivery는 빌드 이후 배포단계부터는 사용자의 승인이 필요하고, Deployment는 모두 자동.
- 중견기업에서는 Continous Delivery를 자주 사용한다. QA의 승인이 떨어져야 배포함.
- 아티팩트 저장소, 테스트 자동화, 배포 자동화, 승인 또는 모니터링으로 이루어져있다.
- 주요 도구
    - CD 시스템 : ArgoCD, Spinnaker
    - 인프라 관리 : Helm, Kustomize, Terraform
    - 배포 전략 : Blue/Green, Canary, Rolling Update
    - 알림/모니터링 : Slack, Prometheus, Grafana
- 운영 환경 배포 속도 증가, 휴먼 에러 감소, 빠른 롤백 또는 자동 복구 가능, 피드백 반영 속도 향상 등 장점.

## 🍀 Container
- 운영체제 수준에서 격리된 환경을 제공하는 기술, 앱을 실행하기 위해 만든 환경
- 앱과 앱의 의존성을 묶어서 동일한 형태로 배포하고 실행할 수 있는 단위
- 실질적으로는 Linux 내에서 다음 리소스 분리 기능을 적용한 기술
    - chroot
    - namespace
    - cGroup
    - Union FileSystem

## 🍀 Container Image
- 컨테이너를 실행하기 위한 모든 구성요소를 포함하는 불변 실행 패키지
- 간단하게 생각하면 공장에서 갓 생산된 스마트폰
- 그 위에 데이터를 쌓음으로써 하나의 컨테이너가 완성되는 구조
- 실행 기반이 되는 VM의 OS나 환경에 영향을 받지않고(이식성), Tag 기반 버전관리가 가능하다(버전관리)
- 가벼운 Alpine과 같은 기반 OS를 사용하면 마찬가지로 가벼운 컨테이너 이미지를 만들 수 있다(경량화), 쓰는사람 나름임

## 🍀 Container Layer
- LowerDir(Image Layer)
    - 컨테이너 이미지
    - 별도로 새로운 이미지를 생성하기 전에는 내용이 수정되지 않음
    - 컨테이너를 생성할때의 기반이 됨
- UpperDir(Container Layer)
    - 컨테이너의 수정사항을 반영하는 레이어
    - 파일에 대한 생성, 수정, 삭제가 모두 반영됨
- MergedDir(Merged Layer)
    - LowerDir과 UpperDIr를 모두 반영한 최종 상태
    - 실제로 사용자에게 제공되는 파일시스템이 이 레이어.

## 🍀 Container Runtime
- 컨테이너 이미지 실행을 담당하는 소프트웨어 구성 요소
- 이미지에서 컨테이너 레이어를 쌓아서 프로세스를 생성하고 격리된 환경에서 실행하도록 해주는 툴
- 기능
    - 풀링(Pulling) : 레지스트리 등에서 이미지를 로컬에 다운로드
    - 언팩(Unpack) : 이미지 레이어를 로컬에 전개
    - 컨테이너 생성 : 격리된 네임스페이스 + cgroups 환경 생성
    - 실행 및 관리 : 컨테이너 프로세스를 실행 및 추적
    - 종료 및 정리 : 컨테이너 중지, 할당된 리소스 해제 및 정리
- 종류
    - dockerd : Docker 엔진의 daemon 런타임
    - CRI-O : Kubernetes의 CRI를 구현한 런타임
    - containerd : Docker가 내부에서 실행하는 고성능 런타임
- Docker는 컨테이너 런타임인가?  
Docker는 containerd를 포함하며 이미지 빌드 툴과 컨테이너 관리를 위한 dockerd가 합쳐진 통합 컨테이너 관리 툴에 더 가까움

## 🍀 Container Orchestration
- 여러 컨테이너를 자동으로 배포, 확장, 운영, 복구하는 기술 및 시스템의 총칭
- 컨테이너 런타임처럼 단일 노드가 아닌 다중 노드에서의 운영이 핵심 (확장성 및 고가용성)
- 주요 기능
    - 컨테이너 스케줄링 : 적절한 노드에 컨테이너를 자동으로 배치
    - 자동 확장/축소 : 수요에 따라 컨테이너 수를 자동으로 조절, 노드 수 또한 마찬가지로 조절
    - 서비스 디스커버리 : 내부 컨테이너 간 통신을 위한 자체적인 주소 생성 및 제공
    - 로드 밸런싱 : 요청을 받아야하는 대상 컨테이너로 고르게 분산
    - 롤링 업데이트 : 다운타임 없이 해당 컨테이너를 새 버전으로 배포
    - 자동 복구 : 컨테이너/노드 오류 시 자동으로 재시작 및 교체

## 🍀 MSA
- 서비스 독립성이 가장 큰 이유다. 장애 전파가 적다.

## 🍀 Service Mesh
- 마이크로서비스간 통신을 제어하고 관리하는 인프라 계층, 네트워크 기능을 애플리케이션 코드와 분리
- MSA는 서비스 간 TLS 통신을 직접 구현해야하지만, Service Mesh는 자동으로 mTLS 처리
- 트래픽을 추적하고 메트릭을 자동으로 수집한다.
- 정책 기반 인증/인가를 설정할 수 있다.
- Istio, Linkerd 등 솔루션이 있다.

## 🍀 IaC(Infrastructure as a Code)
- 인프라를 코드로 정의하고 자동으로 배포, 관리하는 방식
- 수작업으로 인한 휴먼 에러가 방지되고, 여러 스테이지에 대한 인프라 구성이 용이해진다.
- 자동화를 통해 인프라 배포 속도가 향상된다.
- IaC - Terraform

## 🍀 개념 정리
- 앱을 어떻게 새로운 VM에서 기존과 똑같이 실행? → Container (Docker, containerd)
- 컨테이너를 언제 하나하나 수정하고 배포? 죽으면 어떻게 복구? → Container Orchestration
- 빌드 후 결과물을 어떻게 옮김? 테스트 자동화? → CI Pipeline (jenkins, github actions)
- 앱 배포를 하나하나? 배포 후 문제 생기면 롤백은? → CD Pipeline (argocd)
- 인증/인가 서비스를 별도로 다 구축? 내부 트래픽 감시? → Service Mesh (Istio), API Gateway
- 매번 같은 내용으로 구축하는데, 매번 이래야 함? → IaC (terraform)