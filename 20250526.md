# 2025. 05. 26.

## 🍀 Kubernetes (k8s)
쿠버네티스는 컨테이너화된 애플리케이션을 자동으로 배포, 관리, 확장해주는 오픈소스 플랫폼이다.  
구글에서 처음으로 개발했고, **Cloud Native Computing Foundation(CNCF)** 에서 관리한다.  
컨테이너화된 애플리케이션의 배치, 확장 및 관리를 간소화하며, 클라우드 환경에서의 무중단 서비스, 확장성, 높은 가용성을 보장한다.

## 🍀 k8s의 등장배경
도커와 같은 컨테이너 기술이 발달하면서 OS영역까지 관리하지 않아 더욱 빠른 서비스 구동이 가능해졌다.  
하지만 이 복잡한 컨테이너들을 관리할 수 있는 자동화 도구가 필요했다.  

## 🍀 docker compose, k8s 차이
**Docker Compose** 는 옵션을 지정해 수동으로 컨테이너의 수를 바꿔야 한다.  
반면 **k8s** 는 yml 파일에 정의한 설정대로 컨테이너를 생성하거나 삭제하면서 '바람직한 상태'를 유지하는 기능이 있다.

**k8s** 는 문제가 되는 컨테이너를 삭제하고 새로운 컨테이너를 만들거나, 컨테이너가 삭제되면 다시 설정대로 생성하는 등 정해진 상태를 유지한다.  
기본적으로 사람이 개입해서 컨테이너를 삭제하기 보다 삭제 명령이 아니라 yml 파일에서 바람직한 상태를 수정해야 한다.

## 🍀 k8s 구성요소
쿠버네티스 클러스터는 크게 **컨트롤 플레인(Control Plane, Master Node)** 와 **워커 노드(Worker Node)** 로 구성된다.  

### 마스터 노드
컨테이너의 생명주기를 정의하고, 배포, 관리하기 위한 쿠버네티스의 컴포넌트이다.  
컨테이너 등의 상태 설정을 key-value 형태로 저장하기 위해 `etcd` 라는 분산 저장소가 존재한다.  
또한 마스터 노드를 설정하는 관리자 컴퓨터에는 `kubectl` 이 설치되어야 마스터 노드에 로그인하고 설정을 관리할 수 있다.  
* **kube-apiserver**
    * 쿠버네티스 클러스터의 중심 역할을 하는 통로, 모든 명령과 통신은 API 서버를 통해 이루어진다.
    * `etcd` 저장소와 직접 상호 작용하는 유일한 구성요소이다.
* **etcd**
    * 클러스터 상태와 설정 정보를 key-value 쌍으로 보관하는 분산 저장소
    * 클러스터 및 리소스 정보, 상태정보 등이 저장 됨
    * 안정적인 동작을 위해 자료를 분산해서 저장하는 구조를 채택하고 있음
* **kube-scheduler**
    * 새로운 Pod가 생성되면 이를 감지하여 어떤 워커 노드로 배치할지 결정하는 작업을 담당
    * Pod의 리소스 요구사항, 노드의 가용성 등을 모두 고려하여 스케줄링을 결정한다.
* **kube-controller-manager**
    * 클러스터 내에서 실행되는 Controller를 통합 관리하는 프로세스
    * API Server를 통해 클러스터의 상태를 감시하고 조치하는 역할을 담당
    * 지정된 상태를 유지할 수 있도록 지속적으로 모니터링한다
* **cloud-controller-manager**
    * 클라우드 서비스와 연동해 서비스를 생성한다.

### 워커 노드
모든 클러스터는 최소 한 개의 워커노드를 가진다.  
도커 엔진 같은 컨테이너 엔진이 필요하다. (`containerd`, `CRI-O`, `Docker Engine`)  
워커 노드는 구성요소인 Pod를 호스팅한다.
* **kube-let**
    * 클러스터의 각 노드에서 실행되는 에이전트
    * Pod에서 컨테이너가 확실하게 동작하도록 관리한다
    * API 서버를 통해 들어오는 신호를 모니터링하고 Pod 내 컨테이너들이 정상적으로 작동하는지 관리한다
* **kube-proxy**
    * 각 노드에서 실행되며 네트워크 프록시로 동작한다
    * 클러스터 내부 또는 외부의 네트워크 세션에서 Pod로의 네트워크 통신을 허용하는 네트워크 규칙을 유지한다
    * 노드로 들어오고 나가는 네트워크 트래픽을 프록시하고 로드밸런싱을 수행한다

## 🍀 Pod, Service
* **Pod**
    * 클러스터에서 실행중인 컨테이너의 집합
    * Pod 하나에는 컨테이너가 하나 또는 여러 개 구성될 수 있다.
    * 컨테이너 하나를 관리하더라도 Pod로서 다루어야 한다.
* **Service**
    * 네트워크 서비스로 Pod 집합에서 실행중인 애플리케이션들을 노출하는 방법
    * 각 서비스는 고정된 IP를 부여받아 외부에서는 이 IP 주소로 접근하며, 이 때 서비스가 적절한 파드들로 분배한다.

## 🍀 Deployment
ReplicaSet의 상위 개념으로, Pod와 ReplicaSet에 대한 배포를 관리하는 쿠버네티스 오브젝트  
Pod와 ReplicaSet에 대한 선언적 업데이트를 제공하며,  
사용자가 원하는 상태를 정의하면 쿠버네티스가 현재 상태를 이 최종 상태로 맞추기 위해 필요한 모든 작업을 자동으로 수행한다.
* **배포 관리 및 롤백**
    * 운영 중에 애플리케이션의 새 버전을 배포하거나 부하가 증가하면서 Pod를 추가하는 등 여러가지 동작을 관리할 수 있다.
    * 배포에 대한 이력을 관리하며, 배포한 새 버전에 문제가 생긴 경우 쉽게 이전 버전으로 롤백할 수 있다.
* **선언적 업데이트**
    * Deployment Controller가 현재 상태에서 의도하는 상태로 비율을 조정하며 변경한다
    * 사용자는 복잡한 업데이트 절차를 직접 관리할 필요 없이, 단순히 원하는 상태를 정의하면 된다.

## 🍀 ReplicaSet
Pod의 복제본을 관리하고 유지하는 역할을 담당하는 쿠버네티스 오브젝트  
지정된 수의 Pod 복제본을 유지하여 애플리케이션의 가용성을 보장한다.
* **Pod 개수 유지**
    * 다른 운영자가 Pod를 실수로 지우거나 새로 생성하더라도 쿠버네티스 자체에서 Pod의 개수가 3개가 되도록 지속적으로 유지
* **라벨 기반 Pod 선택**
    * ReplicaSet은 라벨을 기준으로 일치하는 Pod를 선택한다
    * 만일 Pod 생성 후 Pod의 라벨이 변경되거나 삭제된다면, ReplicaSet은 Pod가 삭제된 것으로 인지하고 추가 생성한다

## 🍀 Manifest
YAML 또는 JSON 포맷으로 작성되는 쿠버네티스 리소스 오브젝트의 구성을 정의하는 파일이다.  
생성하고자 하는 쿠버네티스 오브젝트를 파일에 정의한 후, `kubectl apply` 를 통해 클러스터에 Manifest 파일을 적용한다.  
Manifest 파일은 크게 `apiVersion`, `kind`, `metadata`, `spec` 의 4가지 주요 필드로 구성된다.